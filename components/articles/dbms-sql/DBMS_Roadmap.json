{
  "title": "Roadmap to DBMS",
  "body": "# DBMS\r\n\r\n* For long integer ```bigint```\r\n* Primary Key can never be NULL but unique key can be\r\n* To remove a column ```Alter table table-name drop column-name```\r\n* To Update Values ```Update Table-name Column-name=value where condition```\r\n* To Delete Values ```Delete from Table-name where condition```\r\n* Query Optimization ~> The query optimizer attempts to determine the most efficient way to execute a given query by considering the possible query plans.\r\n\r\n* Anomally\r\nAnomalies are problems that can occur in poorly planned, un-normalised databases where all the data is stored in one table (a flat-file database).\r\n\r\nInsertion Anomaly - The nature of a database may be such that it is not possible to add a required piece of data unless another piece of unavailable data is also added. E.g. A library database that cannot store the details of a new member until that member has taken out a book.\r\n\r\nDeletion Anomaly - A record of data can legitimately be deleted from a database, and the deletion can result in the deletion of the only instance of other, required data, E.g. Deleting a book loan from a library member can remove all details of the particular book from the database such as the author, book title etc.\r\n\r\nModification Anomaly - Incorrect data may have to be changed, which could involve many records having to be changed, leading to the possibility of some changes being made incorrectly.\r\n\r\n* Problems with File System:\r\n    1. Data Redundancy: It is possible that the same information may be duplicated in different files. ...\r\n    2. Data Inconsistency: ...\r\n    3. Difficulty in Accessing Data: ...\r\n    4. Limited Data Sharing: ...\r\n    5. Integrity Problems: ...\r\n    6. Atomicity Problems: ...\r\n    7. Concurrent Access Anomalies: ...\r\n    8. Security Problems:\r\n\r\n## Keys\r\n* it is used for identifying unique rows from table. It also establishes relationship among tables.\r\n    1. Primary Key – A primary is a column or set of columns in a table that uniquely identifies tuples (rows) in that table and is not NULL.\r\n\r\n    2. Super Key – A super key is a set of one of more columns (attributes) to uniquely identify rows in a table.\r\n\r\n    3. Candidate Key – A super key with no redundant attribute is known as candidate key. There can be more then one candidate key.\r\n\r\n    4. Alternate Key – Out of all candidate keys, only one gets selected as primary key, remaining keys are known as alternate or secondary keys.\r\n\r\n    5. Composite Key – A key that consists of more than one attribute to uniquely identify rows (also known as records & tuples) in a table is called composite key.\r\n\r\n    6. Foreign Key – Foreign keys are the columns of a table that points to the primary key of another table. They act as a cross-reference between tables.\r\n\r\n* What is the Domain of an attribute\r\n    It is the type of value that is present that is int,string,char etc.\r\n\r\n* Normalisation\r\n    1. Functional Dependency ~> Analyse on which dependency database is set, Relationship between two attributes\r\n    2. Remove redundancy\r\n    3. Minimise Insertion/Deletion/Update anomalies\r\n\r\n* Types of languages in DBMS\r\n    1. DDL  ~> Data Definition Language (Create/Alter/Drop/Truncate)\r\n    2. DML ~> Data Manipulation Language (Select,Insert,Update)\r\n    3. DCL ~> Data Control Language (Grant/Revoke)\r\n    4. TCL ~> Trasaction Control Language (Commit/Roll back)\r\n    5. VDL ~> View Definition Language\r\n\r\n* Levels of abstraction in DBMS\r\n    1. Physical ~> This is the lowest level of data abstraction. It describes how data is actually stored in database. You can get the complex data structure details at this level.\r\n    2. Logical ~> It describes what data is stored in database\r\n    3. View ~> This level describes the user interaction with database system.\r\n\r\n* Aggregation\r\n    1. Maintain relationship between 2 RDBMS\r\n    2. Feature of Entity relation model which allow 1 relationship set to participate with another Relationship set\r\n    3. How more then one record collectively represent a dataset\r\n\r\n* Properties of Transaction are ACID properties\r\n* Locking Scheme in Transaction:\r\n    1. Shared Lock ~> Other transaction can only read and not write (paise nikalte samey)\r\n    2. Exclusive Lock ~> Other transaction can neither read nor write (for other operations like pin change karna/check balance)\r\n\r\n* UNIQUE Key can be NULL for once only\r\n* Triggers\r\n    * Set of commands executed when certain event occurrs\r\n* Stored Procedure is basically a set of SQL queries that are executed all together in a pre-maded sequence\r\n\r\n* the most commonly used normal forms:\r\n    1. First normal form(1NF) ~> A relation is in first normal form if every attribute in that relation is singled valued attribute.\r\n    2. Second normal form(2NF) ~> A relation must be in first normal form and relation must not contain any partial dependency.\r\n    3. Third normal form(3NF) ~> Transitive dependencies are removed in this form\r\n    4. Boyce & Codd normal form (BCNF)\r\n\r\n* Weak Entity Set\r\n    A weak entity set is an entity set that does not contain sufficient attributes to uniquely identify its entities\r\n* Multivalue Attrivute\r\n    An attribute that can hold multiple values is known as multivalued attribute. It is represented with double ovals in an ER Diagram.\r\n* Strong Entity Set\r\n    A strong entity set is an entity set that contains sufficient attributes to uniquely identify all its entities.\r\n\r\n* Functional Dependency\r\n    1. It is of 2 types:\r\n        * Trival\r\n        * Non-Trival\r\n* Inference Rule\r\n\r\n* Partial Dependency\r\n    Partial Dependency occurs when a nonprime attribute is functionally dependent on part of a candidate key.\r\n* Fully-functionally Dependency\r\n    An attribute is fully functional dependent on another attribute, if it is Functionally Dependent on that attribute and not on any of its proper subset.\r\n\r\n* Concurrency Control ~> Concurrency control is the procedure in DBMS for managing simultaneous operations without conflicting with each another. It helps you to make sure that database transactions are performed concurrently without violating the data integrity of respective databases.\r\n\r\n# Data Model\r\n<a href=\"https://afteracademy.com/blog/what-is-data-model-in-dbms-and-what-are-its-types\">Learn More</a>\r\n\r\n* Data Model gives us an idea that how the final system will look like after its complete implementation.\r\n* Some of them are:\r\n1. Hierarchical Model ~> Hierarchical Model was the first DBMS model. This model organises the data in the hierarchical tree structure. The hierarchy starts from the root which has root data and then it expands in the form of a tree adding child node to the parent node.\r\n\r\n2. Network Model ~> a record can have more than one parent.\r\n\r\n3. Entity-Relationship Model ~> the real-world problem in the pictorial form to make it easy for the stakeholders to understand. \r\n\r\n4. Relational Model ~> In this model, the data is maintained in the form of a two-dimensional table. All the information is stored in the form of row and columns. The basic structure of a relational model is tables. So, the tables are also called relations in the relational model.\r\n\r\n5. Object-Oriented Data Model ~> both the data and relationship are present in a single structure known as an object. \r\n\r\n6. Object-Relational Data Model ~> This model was built to fill the gap between object-oriented model and the relational model. We can have many advanced features like we can make complex data types according to our requirements using the existing data types.\r\n\r\n7. Flat Data Model ~> It is a simple model in which the database is represented as a table consisting of rows and columns. To access any data, the computer has to read the entire table. This makes the modes slow and inefficient.\r\n\r\n8. Semi-Structured Data Model\r\nAssociative Data Model\r\nContext Data Model\r\n\r\n\r\n\r\n# Basics\r\n* To connect to database ```\\connect root@localhost:3306```\r\n* To disconnect from database ```\\quit```\r\n* To change language from ```JS``` to ```SQL``` use ```\\sql```\r\n* To Create a database ```create database db-name```\r\n* To clear shell screen, use ```Ctrl + L```\r\n* To Create a table \r\n```sql\r\ncreate table tb-name(\r\n    col1-name data-type,\r\n    col2-name data-type\r\n);\r\n```\r\n* To check the schema of table ```describe tb-name```\r\n* To insert row ```insert into tb-name(col1-name,col2-name) values(\"piyush\",12);``` or ```insert into tb-name values(\"piyush\",12);```\r\n\r\n* To delete rows ```delete from tb-name where condition```\r\n* To update rows ```update tb-name set col-name=new-value where condition```\r\n* To LIMIT the no of rows, ```LIMIT count``` is used\r\n* To get rows with unique values ```DISTINCT``` is used as ```SELECT DISTINCT column-name FROM tb-name```\r\n* To Count no of rows in table ```SELECT COUNT(*) FROM tb-name```\r\n* For logical operations ```AND```, ```OR``` are used\r\n* To Apply Condition for range, use ```BETWEEN``` keyword as ```SELECT * FROM tb-name WHERE field1 BETWEEN range-1 AND range-2```\r\n* ```BETWEEN``` is inclusive in nature\r\n* To check condition from a iterative object, use ```IN``` as ```SELECT * FROM tb-name WHERE age IN (2,4,6,8,10)``` , this will result in list of tuples with age equal to 2,4,6,8 or 10.\r\n* Missing or Unknown Values are represented by ```NULL``` in SQL and they can be checked by using ```IS NULL``` or ```IS NOT NULL``` expression\r\n* IN SQL, ```LIKE``` operator is used with ```WHERE``` clause to search for a ```pattern``` in a column. It uses 2 types of wildcards:\r\n    1. ```%``` ~> represents zero, one or more charcater\r\n    2. ```_``` ~> represents a single character\r\n* Similar to ```LIKE```, we can use ```NOT LIKE``` operator for values not matching certain ```pattern```\r\n* To Perform arithematic operations , queries like ```SELECT (a+b)``` or ```SELECT (a-b)``` or ```SELECT (a/b)``` can be used\r\n* Arithematic operations are similar to C programming as Int/Int is INT\r\n* Aliasing ~> Assigning a temporary name to something, it is done in SQL using ```AS``` keyword\r\n* To Comment something in SQL use ```--``` or ```/* */``` for multiline comment\r\n* To Sort results ```ORDER BY``` keyword is used, by default its in ```Ascending``` order and for ```Descending``` order we use ```DESC``` as ```SELECT * FROM tb-name ORDER BY field1 DESC```\r\n* ```ORDER BY``` can be used to sort table data based on multiple columns as ```SELECT * FROM tb-name ORDER BY col1,col2```\r\n* To Count the Value of cells based on Groups, or basically to divide the data into multiple groups, ```GROUP BY``` is used\r\n* ```ORDER BY``` is always used after the ```GROUP BY```\r\n* ```HAVING``` clause is used to use ```AGGREGATE``` functions after ```WHERE``` clause\r\n\r\n## JOIN in DBMS\r\n* To do ```INNER JOIN```, query is ```SELECT * FROM l-table INNER JOIN r-table ON l-table.id=r-table.id;```\r\n* When joining tables with a common field name, we can use ```USING``` as a shortcut as ```SELECT * FROM tb-name1 INNER JOIN tb-name2 USING(common-field-name)```\r\n* To use if else conditions in SQL, we use ```CASE```,```WHEN``` and ```THEN```\r\n```sql\r\nSELECT country_code, size,\r\n  CASE WHEN size > 50000000\r\n            THEN 'large'\r\n       WHEN size > 1000000\r\n            THEN 'medium'\r\n       ELSE 'small' END\r\n       AS popsize_group\r\nINTO pop_plus       \r\nFROM populations\r\nWHERE year = 2015;\r\n```\r\n* To do ```LEFT JOIN```, query is ```SELECT * FROM l-table LEFT JOIN r-table ON l-table.id = r-table.id;```\r\n* To do ```RIGHT JOIN```, query is ```SELECT * FROM r-table RIGHT JOIN l-table ON l-table.id = r-table.id;```\r\n* TO do ```FULL JOIN```,query is ```SELECT * FROM l-table FULL JOIN r-table USING(field)```\r\n\r\n* <u>SET THEORY</u>\r\n* ```UNION``` and ```UNION ALL``` are used to group or merge the output of two or more queries.\r\n* ```UNION``` refers to summing up of only UNIQUE records where as ```UNION ALL``` refers to summing up of all the records\r\n* QUERY is as ```SELECT * FROM tb1 WHERE condition UNION SELECT * FROM tb2 WHERE condition2```, the only thing to make sure is that domain of each field from output of both sub-query should be same\r\n* ```INTERSECT``` is used to extract records that are unique in both the sub queries\r\n* ```SELECT * FROM tb1 INTERSECT SELECT * FROM tb2```\r\n* ```EXCEPT``` is used to find the ```A-B``` of two sub-queries in table, ```SELECT * FROM tb1 EXCEPT SELECT * FROM tb2```\r\n* ```SEMI JOIN```, is query where contents in tb1 match to contents in tb2, ```SELECT * FROM tb1 WHERE field IN (SELECT * FROM tb2);```\r\n* ```ANTI JOIN```, is query where contents in tb1 not match to contents in tb2, ```SELECT * FROM tb1 WHERE field NOT IN (SELECT * FROM tb2);```\r\n* Sample of Subquery inside query\r\n```sql\r\n-- Select fields\r\nSELECT *\r\n  -- From populations\r\n  FROM populations\r\n-- Where life_expectancy is greater than\r\nWHERE life_expectancy > 1.15 * \r\n  -- 1.15 * subquery\r\n  (\r\n    SELECT AVG(life_expectancy)\r\n      FROM populations\r\n      WHERE year = 2015\r\n  ) AND year = 2015;\r\n```\r\n* Subqueries are most frequently used in ```WHERE``` clause\r\n* Cross JOIN is used as ```SELECT * FROM tb1 CROSS JOIN tb2```\r\n* To get the Round-of value, we can use ```ROUND(value,decimal-pomit)``` to get the required output as ```ROUND(0.3434,2)``` to get ```0.34```\r\n\r\n## Correlated Subqueries\r\n* Simple Subquery Vs Correlated Subqueries\r\n<table>\r\n<tr>\r\n    <th>Simple Subquery</th>\r\n    <th>Correlated Subquery</th>\r\n</tr>\r\n<tr>\r\n    <td>Can be run independently from the main query </td>\r\n    <td>Dependent on the main query to eecute </td>\r\n</tr>\r\n<tr>\r\n    <td>Evaluated once in the whole query</td>\r\n    <td> Evaluated in loops -> Significantly slows down query runtime</td>\r\n</tr>\r\n</table>\r\n\r\n* To get Month from ```Date```, we can use ```EXTRACT(MONTH FROM DATE)```\r\n* Correlated Nested Subqueries can be correlated or uncorrelated\r\n    1. They can be a combination of two\r\n    2. Can reference information from the outer subquery or main query\r\n\r\n## Common Table Expressions\r\n* Table declared before main query\r\n* Named and referenced later in ```FROM``` statement\r\n```sql\r\nWITH cte AS (\r\n    SELECT col1, col2 \r\n    FROM table)\r\nSELECT \r\n    AVG(col1) AS avg_col\r\nFROM cte;\r\n```\r\n* Executed only once\r\n    1. CTE is stored in memory\r\n    2. Improves query performance\r\n* Improving organization of queries\r\n* Referencing other CTEs\r\n* Referencing itself (SELF JOIN)\r\n* To declare multiple ```CTE``` just separate them with a ```comma(,)```\r\n```sql\r\nWITH home AS (\r\n  SELECT m.id, m.date, \r\n  \t\t t.team_long_name AS hometeam, m.home_goal\r\n  FROM match AS m\r\n  LEFT JOIN team AS t \r\n  ON m.hometeam_id = t.team_api_id),\r\n-- Declaring another CTE after ,\r\n-- Declare and set up the away CTE\r\naway AS (\r\n  SELECT m.id, m.date, \r\n  \t\t t.team_long_name AS awayteam, m.away_goal\r\n  FROM match AS m\r\n  LEFT JOIN team AS t \r\n  ON m.awayteam_id = t.team_api_id)\r\n-- Select date, home_goal, and away_goal\r\nSELECT \r\n\thome.date,\r\n    home.hometeam,\r\n    away.awayteam,\r\n    home.home_goal,\r\n    away.away_goal\r\n-- Join away and home on the id column\r\nFROM home\r\nINNER JOIN away\r\nON home.id = away.id;\r\n```\r\n\r\n## Window Functions\r\n* Functions that Perform calculations on an already generated result set (a window)\r\n* Aggregate Calculations\r\n    1. Similar to subqueries in ```SELECT```\r\n    2. Running totals, rankings, moving averages\r\n```sql\r\nSELECT\r\n    date,\r\n    (home_goal + away_goal) AS goals,\r\n    AVG(home_goal + away_goal) OVER() AS overall_avg\r\nFROM match\r\nWHERE season = '2011/2012';\r\n```\r\n```sql\r\n-- RANK() function orders rank from smallest to largest value\r\nSELECT \r\n    date,\r\n    (home_goal + away_goal) AS goals,\r\n    RANK() OVER(ORDER BY home_goal + away_goal) AS goals_rank\r\nFROM match\r\nWHERE season = '2011/2012';\r\n```\r\n* Processed after every part of query except ```ORDER BY```\r\n    1. Uses information in result set rather than database\r\n* Available in PostgreSQL, Oracle   , MySQL, SQL Server.. but not SQLite\r\n```sql\r\n-- PARTITION BY\r\n/*\r\nCalculates separate values for different categories\r\nCalculates different calculations in the same column\r\n*/\r\nSELECT\r\n    date,\r\n    (home_goal + away_goal) AS goals,\r\n    AVG(home_goal + away_goal) OVER(PARTITION BY season) AS overall_avg\r\nFROM match\r\nWHERE season = '2011/2012';\r\n```\r\n\r\n### Sliding Windows\r\n* Performs calculations relative to the current row\r\n* Can be used to calculate running totals, sums, averages, etc\r\n* Can be partitioned by one or more columns\r\n```sql\r\nROWS BETWEEN <start> AND <finish>\r\n```\r\n* Keywords that can be used in place of start and finish:\r\n    1. PRECEDING\r\n    2. FOLLOWING\r\n    3. UNBOUNDED PRECEDING -> since the beginning\r\n    4. UNBOUNDED FOLLOWING\r\n    5. CURRENT ROW -> stop at current row\r\n```sql\r\nSELECT \r\n\tdate,\r\n\thome_goal,\r\n\taway_goal,\r\n    -- Create a running total and running average of home goals\r\n    SUM(home_goal) OVER(ORDER BY date \r\n         ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS running_total,\r\n    AVG(home_goal) OVER(ORDER BY date \r\n         ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS running_avg\r\nFROM match\r\nWHERE \r\n\thometeam_id = 9908 \r\n\tAND season = '2011/2012';\r\n```\r\n\r\n* to add a ```DATE``` in sql, we use ```Date``` data-type and it is inserted as ```DATE 'yyyy/MM/dd'``` format\r\n* to add a ```TIMESTAMP``` in sql, we use ```timestamp``` data-type and it is inserted as ```TIMESTAMP 'yyyy/MM/dd HH:MM:SS```\r\n* Timestamp from ```1900``` onwards can only be inserted into SQL\r\n* To insert characters like ```'(single quote)```, one need to use ```\\(backslash)```\r\n* to use column names with space in between like ```Column Number 1```, we need to represent it inside ```back-quotes``` like ``` `Column Number 1` ``` though it is preferable to always use ```underscore _``` instead of ```space```\r\n* To change password use ```ALTER USER 'root'@'localhost' IDENTIFIED BY 'New-Password'```\r\n\r\n\r\n# View\r\n* It is a keyword which can be used as data table\r\n* It creates an alias for a ```SELECT``` query\r\n* Its syntasx is\r\n```sql\r\nCREATE VIEW name_for_view AS select_query\r\n```\r\n\r\n# Stored Function\r\n* Delimeters are applied at the client \r\n```sql\r\nDELIMETER //\r\nCREATE FUNCTION track_len(seconds INT)\r\nRETURNS VARCHAR(16)\r\nDETERMINISTIC\r\nBEGIN\r\n    RETURN CONCAT_WS(':',seconds DIV 60,LPAD(second MOD 60,2,'0'));\r\nEND //\r\nDELIMETER ;\r\n```\r\n* To delete a function ```DROP FUNCTION IF EXISTS function_name```\r\n* To list functions created by you ```SHOW FUNCTION STATUS WHERE DEFINER LIKE 'admin%';```\r\n\r\n# Procedure\r\n* It is called using ```CALL``` keyword as ```CALL procedure_name (any_param_if_req)```\r\n```sql\r\nDELIMITER //\r\nCREATE PROCEDURE procedure_name (IN parameter VARCHAR(255), OUT outp VARCHAR(255))\r\nBEGIN\r\n    SELECT * INTO outp FROM album;\r\n    SELECT * FROM track;\r\nEND\r\nDELIMITER ;\r\nCALL procedure_name(\"parameter_value\",@output_variable);\r\nSELECT @output_variable;\r\n```\r\n* We can call any function/procedure from inside of another function or procedure\r\n* To Check all procedures use ```SHOW PROCEDURES STATUS WHERE DEFINER LIKE 'admin%';```\r\n* To drop procedure use ```DROP PROCEDURE IF EXISTS procedure_name```\r\n\r\n\r\n# Variables and Loops\r\n* An Example for use of variables and loops with a procedure\r\n```sql\r\nUSE db_name;\r\nDROP PROCEDURE IF EXISTS str_count;\r\nDELIMITER //\r\nCREATE PROCEDURE str_count()\r\nBEGIN\r\n    DECLARE max_value INT UNSIGNED DEFAULT 5;\r\n    DECLARE int_value INT UNSIGNED DEFAULT 0;\r\n    DECLARE str_value VARCHAR(255) DEFAULT '';\r\n    WHILE int_value < max_value DO\r\n        SET int_value = int_value + 1;\r\n        SET str_value = CONCAT(str_value,int_value,\" \");\r\n    END WHILE;\r\n    SELECT str_value;\r\nEND //\r\nDELIMITER ;\r\nCALL str_count();\r\n```\r\n\r\n# Transactions\r\n* One for all - all for one\r\n* Follows the ACID properties\r\n* Its Syntax is as\r\n```sql\r\nSTART TRANSACTION\r\n    INSERT INTO TB1\r\n    INSERT INTO TB2\r\n    SELECT FROM TB1\r\n    INSERT INTO TB3\r\nEND TRANSACTION\r\n```\r\n* State of database rolls back to original shape if any statement fails from an transaction\r\n* Each transaction occurs isolately\r\n* Example\r\n```sql\r\nDROP TABLE IF EXISTS widgetInventory;\r\nDROP TABLE IF EXISTS widgetSales;\r\nCREATE TABLE widgetInventory(\r\n    id INTEGER AUTO_INCREMENT PRIMARY KEY,\r\n    description TEXT,\r\n    onhand INTEGER NOT NULL\r\n);\r\nCREATE TABLE widgetSales (\r\n    id INTEGER AUTO_INCREMENT PRIMARY KEY,\r\n    inv_id INTEGER,\r\n    quan INTEGER,\r\n    price INTEGER\r\n);\r\nINSERT INTO widgetInventory (description, onhand ) VALUES ('rock',25), ('paper',25), ('scissors',25);\r\nSELECT * from widgetInventory;\r\n```\r\n* Transaction Example\r\n```sql\r\nSTART TRANSACTION;\r\nINSERT INTO widgetSales ( inv_id,quan,price) VALUES (1,5,500);\r\nUPDATE widgetInventory SET onhand = (onhand-5) WHERE id=1;\r\nCOMMIT;\r\nSELECT * FROM widgetSales;\r\nSELECT * FROM widgetInventory;\r\n```\r\n* Rollback example\r\n```sql\r\nSTART TRANSACTION;\r\nINSERT INTO widgetInventory (description,onhand) VALUES ('toy',24);\r\nROLLBACK;\r\n```\r\n* Transactions are way faster as compared to single queries\r\n* An example to check the same is\r\n```sql\r\n-- code without transaction takes about 34 sec\r\n-- code with transaction takes about 0.42 sec\r\n-- All thanks to buffering all together\r\nDROP TABLE IF EXISTS test;\r\nDROP PROCEDURE IF EXISTS insert_loop;\r\nCREATE TABLE test (id INTEGER AUTO_INCREMENT PRIMARY KEY NOT NULL, data TEXT);\r\nDELIMITER //\r\nCREATE PROCEDURE insert_loop(IN count INT UNSIGNED )\r\nBEGIN\r\n    DECLARE accum INT UNSIGNED DEFAULT 0;\r\n    DECLARE start_time VARCHAR(32);\r\n    DECLARE end_time VARCHAR(32);\r\n    SET start_time = SYSDATE(6);\r\n    WHILE   accum < count DO\r\n        SET accum = accum + 1;\r\n        INSERT INTO test (data) VALUES (\"This is text\");\r\n    END WHILE;\r\n    SET end_time = SYSDATE(6);\r\n    SELECT TIME_FORMAT(start_time,\"%T.%f\") AS 'Start',\r\n        TIME_FORMAT(end_time,\"%T.%f\") AS 'End',\r\n        TIME_FORMAT(TIMEDIFF(end_time,start_time),\"%s.%f\") AS \"Elapsed Secs\";\r\nEND //\r\nDELIMITER ;\r\n-- START TRANSACTION;\r\ncall insert_loop(10000);\r\n-- COMMIT;\r\n```\r\n\r\n# Triggers\r\n```sql\r\nDROP TRIGGER IF EXISTS newWidgetSale;\r\nDROP TABLE IF EXISTS widgetSale;\r\nDROP TABLE IF EXISTS widgetCustomer;\r\nCREATE TABLE widgetCustomer (\r\n    id INTEGER AUTO_INCREMENT PRIMARY KEY, name VARCHAR(64), last_order_id INT\r\n);\r\nCREATE TABLE widgetSale (\r\n    id INTEGER AUTO_INCREMENT PRIMARY KEY, item_id INT, customer_id INT, quan INT, price INT\r\n);\r\nINSERT INTO widgetCustomer (name) VALUES (\"BOB\"),(\"Sally\"),(\"Fred\");\r\nSELECT * FROM widgetCustomer;\r\nDELIMITER //\r\nCREATE TRIGGER newWidgetSale AFTER INSERT ON widgetSale\r\n    FOR EACH ROW\r\n    BEGIN\r\n        UPDATE widgetCustomer SET last_order_id = new.id WHERE widgetCustomer.id = NEW.customer_id;\r\n    END //\r\nDELIMITER ;\r\nINSERT INTO widgetSale (item_id,customer_id,quan,price) VALUES (1,3,5,1995),(2,2,3,1495),(3,1,1,2995);\r\nSELECT * FROM widgetSale;\r\nSELECT * FROM widgetCustomer;\r\n```\r\n* To show triggers present in a database, use ```SHOW TRIGGERS```\r\n* Triggers are associated with the table thus dropping a table will drop the triggers as well\r\n* To drop specific trigger ```DROP TRIGGER IF  EXISTS trigger_name;```\r\n\r\n* To Prevent a code from being inserted using ```triggers```\r\n```sql\r\nDELIMITER //\r\nCREATE TRIGGER updateWidgetSale BEFORE  UPDATE ON widgetSale\r\n    FOR EACH ROW\r\n    BEGIN\r\n        IF OLD.id = NEW.id AND OLD.reconciled = 1 THEN\r\n            SIGNAL SQLSTATE \"45000\" set message_text = \"Cannot update reconciled row: \";\r\n        END IF\r\n    END //\r\nDELIMITER ;\r\n\r\n```\r\n# DBMS RoadMap\r\n[complete Road Map ](https://whimsical.com/dbms-roadmap-TciRgjVXRmJYjgtFiyX37R)\r\n\r\n# SQL languages\r\n\r\n**DDL** is short name of Data Definition Language, which deals with database schemas and descriptions, of how the data should reside in the database.\r\n\r\n**DML** is short name of Data Manipulation Language which deals with data manipulation, and includes most common SQL statements such SELECT, INSERT, UPDATE, DELETE etc, and it is used to store, modify, retrieve, delete and update data in database.\r\n\r\n**DCL** is short name of Data Control Language which includes commands such as GRANT, and mostly concerned with rights, permissions and other controls of the database system.\r\n\r\n# Datatypes\r\nText types\r\n\r\n| Data type        | Description                                                                                                                                                                                                                                                                                      |\r\n|------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\r\n| CHAR(size)       | Holds a fixed length string (can contain letters, numbers, and special characters). The fixed size is specified in parenthesis. Can store up to 255 characters                                                                                                                                   |\r\n| VARCHAR(size)    | Holds a variable length string (can contain letters, numbers, and special characters). The maximum size is specified in parenthesis. Can store up to 255 characters. Note: If you put a greater value than 255 it will be converted to a TEXT type                                               |\r\n| TINYTEXT         | Holds a string with a maximum length of 255 characters                                                                                                                                                                                                                                           |\r\n| TEXT             | Holds a string with a maximum length of 65,535 characters                                                                                                                                                                                                                                        |\r\n| BLOB             | For BLOBs (Binary Large OBjects). Holds up to 65,535 bytes of data                                                                                                                                                                                                                               |\r\n| MEDIUMTEXT       | Holds a string with a maximum length of 16,777,215 characters                                                                                                                                                                                                                                    |\r\n| MEDIUMBLOB       | For BLOBs (Binary Large OBjects). Holds up to 16,777,215 bytes of data                                                                                                                                                                                                                           |\r\n| LONGTEXT         | Holds a string with a maximum length of 4,294,967,295 characters                                                                                                                                                                                                                                 |\r\n| LONGBLOB         | For BLOBs (Binary Large OBjects). Holds up to 4,294,967,295 bytes of data                                                                                                                                                                                                                        |\r\n| ENUM(x,y,z,etc.) | Let you enter a list of possible values. You can list up to 65535 values in an ENUM list. If a value is inserted that is not in the list, a blank value will be inserted.Note: The values are sorted in the order you enter them.You enter the possible values in this format: ENUM('X','Y','Z') |\r\n| SET              | Similar to ENUM except that SET may contain up to 64 list items and can store more than one choice                                                                                                                                                                                               |\r\n\r\nNumber types\r\n\r\n| Data type       | Description                                                                                                                                                                                                                           |\r\n|-----------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\r\n| TINYINT(size)   | -128 to 127 normal. 0 to 255 UNSIGNED*. The maximum number of digits may be specified in parenthesis                                                                                                                                  |\r\n| SMALLINT(size)  | -32768 to 32767 normal. 0 to 65535 UNSIGNED*. The maximum number of digits may be specified in parenthesis                                                                                                                            |\r\n| MEDIUMINT(size) | -8388608 to 8388607 normal. 0 to 16777215 UNSIGNED*. The maximum number of digits may be specified in parenthesis                                                                                                                     |\r\n| INT(size)       | -2147483648 to 2147483647 normal. 0 to 4294967295 UNSIGNED*. The maximum number of digits may be specified in parenthesis                                                                                                             |\r\n| BIGINT(size)    | -9223372036854775808 to 9223372036854775807 normal. 0 to 18446744073709551615 UNSIGNED*. The maximum number of digits may be specified in parenthesis                                                                                 |\r\n| FLOAT(size,d)   | A small number with a floating decimal point. The maximum number of digits may be specified in the size parameter. The maximum number of digits to the right of the decimal point is specified in the d parameter                     |\r\n| DOUBLE(size,d)  | A large number with a floating decimal point. The maximum number of digits may be specified in the size parameter. The maximum number of digits to the right of the decimal point is specified in the d parameter                     |\r\n| DECIMAL(size,d) | A DOUBLE stored as a string , allowing for a fixed decimal point. The maximum number of digits may be specified in the size parameter. The maximum number of digits to the right of the decimal point is specified in the d parameter |\r\n\r\nDate types\r\n\r\n| Data type   | Description                                                                                                                                                                                                                              |\r\n|-------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\r\n| DATE()      | A date. Format: YYYY-MM-DDNote: The supported range is from '1000-01-01' to '9999-12-31'                                                                                                                                                 |\r\n| DATETIME()  | *A date and time combination. Format: YYYY-MM-DD HH:MI:SSNote: The supported range is from '1000-01-01 00:00:00' to '9999-12-31 23:59:59'                                                                                                |\r\n| TIMESTAMP() | *A timestamp. TIMESTAMP values are stored as the number of seconds since the Unix epoch ('1970-01-01 00:00:00' UTC). Format: YYYY-MM-DD HH:MI:SSNote: The supported range is from '1970-01-01 00:00:01' UTC to '2038-01-09 03:14:07' UTC |\r\n| TIME()      | A time. Format: HH:MI:SSNote: The supported range is from '-838:59:59' to '838:59:59'                                                                                                                                                    |\r\n| YEAR()      | A year in two-digit or four-digit format.Note: Values allowed in four-digit format: 1901 to 2155. Values allowed in two-digit format: 70 to 69, representing years from 1970 to 2069                                                     |\r\n\r\n# Database\r\nCreate\r\n```sql\r\ncreate database dbname;\r\n```\r\nDrop\r\n```sql\r\ndrop database dbname;\r\n```\r\n\r\n# Table\r\nCheck if not exit and create\r\n```sql\r\nIF OBJECT_ID('tbl_kunde', N'U') is not null\r\n\tdrop table tbl_kunde;\r\nGO\r\ncreate table tbl_kunde (\r\n  id_kunde int not null primary key,\r\n  fi_moral_nr int,\r\n  name varchar(25) not null,\r\n  vorname varchar not null,\r\n  wohnort varchar\r\n);\r\nGO\r\n```\r\n\r\n# Alter Table\r\nPrimary Key\r\n```sql\r\nALTER TABLE tbl_kunde ADD PRIMARY KEY (id_kunde);\r\n```\r\nForeign Key\r\n```sql\r\nALTER TABLE tbl_kunde ADD CONSTRAINT FK_fi_moral_nr FOREIGN KEY (fi_moral_nr)\r\n  REFERENCES tkey_moral\r\n  ON UPDATE CASCADE\r\n  ON DELETE SET NULL;\r\n```\r\nConstraint\r\n```sql\r\nALTER TABLE tkey_moral ADD CONSTRAINT PK_id_moral_nr PRIMARY KEY (id_moral_nr);\r\nALTER TABLE tbl_kunde ADD CONSTRAINT FK_fi_moral_nr FOREIGN KEY (fi_moral_nr)\r\n  REFERENCES tkey_moral\r\n  ON UPDATE CASCADE\r\n  ON DELETE SET NULL;\r\n```\r\n# Insert\r\nSelected fields\r\n```sql\r\ninsert into tkey_moral (id_moral_nr, moral_bez) values (1, 'gut'), (2, 'schlecht'), (3, 'schlecht');\r\n```\r\n\r\nAll fields\r\n```sql\r\nINSERT INTO tbl_kunde VALUES (3838,1,'Meier','Laura','Waldibrücke')\r\n```\r\n# Update\r\nUpdate by condition\r\n```sql\r\nupdate tbl_kunde set name = 'Menzer' where name = 'Waltenspühl-Menzer'\r\nupdate tass_police set praem_stufe = 101 where praem_stufe = 108\r\n```\r\n\r\n# Delete\r\nAll\r\n```sql\r\ndelete from tbl_kunde\r\n```\r\nCondition\r\n```sql\r\ndelete from tkey_moral where id_moral_nr = 4\r\ndelete from tbl_kunde where vorname = 'Peter' and name = 'Fischer' or vorname = 'Martin' and name = 'Müller'\r\n```\r\n\r\n# Index\r\nCreate\r\n```sql\r\ncreate unique index ix_kund_name on tbl_kunde (name)\r\n```\r\nDisable\r\n```sql\r\nalter index ix_kund_name on tbl_kunde disable\r\n```\r\nRebuild\r\n```sql\r\nalter index ix_kund_name on tbl_kunde rebuild\r\n```\r\nReorganize\r\n```sql\r\nalter index ix_kund_name on tbl_kunde reorganize\r\n```\r\nDrop\r\n```sql\r\ndrop index ix_kund_name on tbl_kunde\r\n```\r\nAlter\r\n```sql\r\ndrop index ix_kund_name on tbl_kunde\r\n```\r\n\r\n#Type\r\ncreate\r\n```sql\r\ncreate type tp_moralisches from numeric(9,0)\r\n```\r\n\r\n#Login\r\nchange password\r\n```sql\r\nalter login stud23 with password = 'hello' old_password = 'pass_wd23'\r\n```\r\n\r\n#User\r\ncreate\r\n```sql\r\ncreate user romulus from login romulus\r\n```\r\ndrop\r\n```sql\r\ndrop user romulus\r\n```\r\n\r\n# Grant/ Revoke\r\nAvailable permissions: CREATE DEFAULT, CREATE FUNCTION, CREATE \r\nPROCEDURE, CREATE ROLE, CREATE TABLE, CREATE TYPE, CREATE VIEW, \r\nDELETE, EXECUTE, INSERT, SELECT, UPDATE\r\n\r\nGrant rights\r\n```sql\r\ngrant select, insert, delete, references, update to romulus\r\n```\r\nGrant refrences\r\n```sql\r\ngrant references (id_moral_nr) on tkey_moral to romulus\r\n```\r\nRevoke\r\n```sql\r\nrevoke insert, delete, references, update to romulus\r\n```\r\n\r\n#Role\r\nCreate\r\n```sql\r\ncreate role verkauf\r\n```\r\nAdd member\r\n```sql\r\nexec sp_addrolemember 'verkauf', 'anna'\r\n```\r\n\r\n#Grant Role\r\nGrant rights\r\n```sql\r\ngrant select, update, insert, delete on tbl_kunde to verkauf\r\n```\r\n\r\n#View\r\nCreate detailed\r\n```sql\r\nCREATE VIEW v_kunden (id, name, vorname, ort, police, gebiet) AS\r\n  SELECT k.id_kunde, k.name, k.vorname, k.wohnort, v.vers_bez,\r\n         v.vers_gebiet\r\n    FROM tbl_kunde AS k, tkey_versicherung AS v, tass_police AS p\r\n      WHERE k.id_kunde = p.id_fi_kunde\r\n        AND p.id_fi_vers_art = v.id_vers_art;\r\n```\r\nCreate simple\r\n```sql\r\ncreate view plain as select id_kunde, name, vorname from tbl_kunde\r\n```\r\nCreate advanced\r\n```sql\r\ncreate view v_umsatz as select sum(cast(bezahlt as float)) as 'Umsatz aus Policen' from tass_police\r\n```\r\n\r\n#Select\r\nBasic\r\n```sql\r\nselect dt_jahr from dbo.tbl_stueck\r\n```\r\nCondition\r\n```sql\r\nselect dt_jahr from dbo.tbl_stueck where dt_jahr is not null\r\n```\r\nOrder\r\n```sql\r\nselect dt_jahr from dbo.tbl_stueck\r\nwhere dt_jahr is not null\r\norder by dt_jahr desc\r\n```\r\nDistinct\r\n```sql\r\nselect distinct dt_jahr from dbo.tbl_stueck\r\nwhere dt_jahr is not null\r\norder by dt_jahr asc\r\n```\r\nAnd Condition\r\n```sql\r\nselect * from tbl_stueck where dt_jahr = 1970 and dt_zeit > 3\r\n```\r\nBetween\r\n```sql\r\nselect * from tbl_stueck where dt_jahr = 1970 and dt_zeit between 3 and 10\r\n```\r\nLike\r\n```sql\r\nselect * from tbl_stueck where dt_stueck_titel like 'Let%'\r\n```\r\nCount\r\n```sql\r\nselect count(dt_stueck_titel) from tbl_stueck where dt_stueck_titel like 'Let%'\r\n```\r\nHaving and without join\r\n```sql\r\nselect i.dt_name, count(s.dt_stueck_titel) from tbl_stueck as s, tkey_interpret as i\r\nwhere  s.fi_interpret = i.id_interpret\r\ngroup by i.dt_name\r\nhaving count(s.dt_stueck_titel) >10\r\norder by count(s.dt_stueck_titel) de\r\n```\r\n#Join the hard way\r\nInner Join\r\n```sql\r\nselect s.dt_stueck_titel, i.dt_name\r\nfrom tbl_stueck as s, tkey_interpret as i\r\nwhere  s.fi_interpret = i.id_interpret\r\norder by s.dt_stueck_titel\r\n```\r\nMulti Join\r\n```sql\r\nselect sa.id_jahr, st.dt_stueck_titel, ip.dt_name\r\nfrom tbl_stueck as st, tass_stueck_sampler as ss, tkey_sampler as sa, tkey_interpret as ip\r\nwhere ss.id_fi_stueck_nr = st.id_stueck_nr \r\nand ss.id_fi_jahr = sa.id_jahr\r\nand  st.fi_interpret = ip.id_interpret\r\norder by  st.dt_stueck_titel\r\n```\r\n\r\n#Join the right way\r\nInner Equi Key Joining\r\n```sql\r\nselect dt_stueck_titel, dt_name\r\nfrom tbl_stueck join tkey_interpret \r\non fi_interpret = id_interpret\r\norder by dt_stueck_titel\r\n```\r\nMulti Inner Equi Key Joining\r\n```sql\r\nselect id_fi_jahr, dt_stueck_titel, dt_name\r\nfrom tbl_stueck\r\njoin tass_stueck_sampler on id_fi_stueck_nr = id_stueck_nr\r\njoin tkey_interpret on fi_interpret = id_interpret\r\norder by  dt_stueck_titel\r\n```\r\n\r\n#About Joins\r\n![sql join summary](http://i.stack.imgur.com/hzl8e.png)\r\n```sql\r\nSELECT customers.id, customers.name, items.name, customers.state \r\nFROM customers, items\r\nWHERE customers.id=seller_id\r\nORDER BY customers.id\r\n```\r\n**Join tables** -> Joining two tables together in a query output. The third line is important because it shows how the two tables are related (in this case it is their key values).   \r\n\r\n```sql\r\nSELECT customers.name, items.name FROM customers\r\nLEFT OUTER JOIN items ON customers.id=seller_id\r\n```\r\n**LEFT/RIGHT OUTER JOIN** -> Takes the table left of the word 'LEFT' or 'RIGHT' (in this case customers) and joins it regardless of whether it has any values or not. So the above statement shows all users/customers, even if they aren't selling anything.  \r\n\r\n#Select with Subqueries \r\nSelect max and min values\r\n```sql\r\nselect dt_stueck_titel as Titel, dt_zeit as Zeit\r\nfrom tbl_stueck\r\nwhere dt_zeit = (select max(dt_zeit) from tbl_stueck)\r\nor dt_zeit = (select min(dt_zeit) from tbl_stueck)\r\norder by dt_zeit;\r\n```\r\nSelect with query in condition\r\n```sql\r\nselect dt_stueck_titel as Titel, dt_zeit as Zeit\r\nfrom tbl_stueck\r\nwhere dt_zeit between (select avg(dt_zeit) from tbl_stueck)*0.9\r\nand (select avg(dt_zeit) from tbl_stueck)*1.1\r\norder by dt_zeit;\r\n```\r\nSelect query as value\r\n```sql\r\nselect dt_stueck_titel as Titel,\r\ndt_zeit/(select avg(dt_zeit) from tbl_stueck)*100 as Zeit\r\nfrom tbl_stueck\r\nwhere dt_stueck_titel = 'You Shook Me'\r\n```\r\n\r\n#Union\r\nUnify two result sets with a condition\r\n```sql\r\nselect *  from\r\n(select dt_stueck_titel as titel, 'stück' as 'type' from tbl_stueck\r\nunion\r\nselect dt_name as titel,  'inter' as 'type' from tkey_interpret\r\nunion\r\nselect dt_stao as titel,  'stao' as 'type' from tkey_standort) as t\r\nwhere t.titel like '%boy%'\r\n```\r\n\r\n#Transactions\r\nRun a transaction\r\n```sql\r\nbegin transaction\r\nupdate tass_police set bezahlt = 0 where id_fi_kunde = 3533 and id_fi_vers_art = 1700\r\ncommit\r\n-- or rollback\r\n```\r\n\r\n#Function\r\nA function can be called from inside a statement just like any other function and can return a scalar value.\r\n\r\nCreate - Get value from table\r\n```sql\r\ncreate function f_plic_bez()\r\n  returns decimal(10,2)\r\n  as begin\r\n  return (select sum(bezahlt) from tass_police)\r\n  end;\r\ngo\r\nselect  dbo.f_plic_bez() AS 'Summe aller bezahlten Leistungen'\r\ngo\r\n```\r\nDrop\r\n```sql\r\ndrop function f_bezahlt_versich\r\n```\r\nCreate - With parameters\r\n```sql\r\ncreate function f_rabatt(@name varchar(40), @vers varchar(30))\r\n  returns int\r\n  as begin\r\n  return (select (praem_stufe-100)*10 from  tass_police\r\n  join tbl_kunde on id_fi_kunde = id_kunde\r\n  join tkey_versicherung on id_fi_vers_art = id_vers_art\r\n  where name = @name and vers_bez = @vers)\r\n  end\r\n```\r\n\r\n#Procedure\r\nStored procedures are stored as precompilated code (stored routine) and called by the programmer wherever it wants to fire. Stored procedure can return value(s).\r\n\r\nCreate and execute\r\n```sql\r\nCREATE PROCEDURE p_polic_del @fname VARCHAR(30), @versich VARCHAR(30)\r\n  AS\r\n  BEGIN\r\n    DELETE FROM tass_police\r\n      FROM tbl_kunde, tkey_versicherung\r\n        WHERE name = @fname\r\n          AND id_kunde = id_fi_kunde\r\n          AND id_fi_vers_art = id_vers_art\r\n          AND vers_bez = @versich\r\n    IF @@ROWCOUNT = 0\r\n      PRINT 'Police existiert nicht.'\r\n      ELSE PRINT 'Löschung vollzogen.'\r\n  END\r\nGO\r\n\r\nEXECUTE p_polic_del 'Meier', 'Taggeld';\r\n```\r\n\r\n#Variables\r\nDeclare\r\n```sql\r\nDECLARE @veraenderung SMALLINT = 180;\r\nDECLARE @neue_summe INT;\r\n```\r\n\r\n#Trigger\r\nTriggers are named database objects fired automatically when insert, delete, update (or other event) occurred, there can be no explicit invocation. Trigger can not return any data.\r\n\r\nCreate simple\r\n```sql\r\ncreate trigger t_ort on tbl_kunde\r\n  after insert, update\r\n  as beginn\r\n    set @ort = select wohnort from inserted)\r\n    if((@ort like '/^[A-Z]') && len(@ort) < 2)\r\n      rollback transaction\r\n  end\r\nend\r\n```\r\n\r\nDrop\r\n```sql\r\ndrop trigger t_ort\r\n```\r\nChecks the referential integrity\r\n```sql\r\ncreate trigger t_bst_mut on bst\r\n\tfor insert, update\r\n\tas\r\n\tbegin\r\n\t\tset nocount on;\r\n\t\tif(select id_fi_k from inserted) NOT IN (select id_kund from knd)\r\n\t\t\tbegin\r\n\t\t\t\traiserror('Es besteht kein entsprechender Kunde.', 15, 1);\r\n\t\t\t\trollback transaction;\r\n\t\t\tend\r\n\tend;\r\n```\r\nReplaces on delete no action\r\n```sql\r\ncreate trigger t_ku_del on knd\r\n\tfor delete\r\n\tas\r\n\tbegin\r\n\t\tset nocount on;\r\n\t\tif((select id_kunde from deleted) IN (select id_fi_k from bst))\r\n\t\t\tbegin\r\n\t\t\t\traiserror('Löschung verwert; es bestehen noch Bestelungen für diesen Kunden.', 15, 1)\r\n\t\t\t\trollback transaction\r\n\t\t\tend\r\n\tend;\r\n```\r\nReplaces on update cascade\r\n```sql\r\ncreate trigger t_update_knd on knd\r\n\tafter update\r\n\tas\r\n\tbegin\r\n\t\tset nocount on;\r\n\t\tupdate bst set id_fi_k = (select id_kund from inserted)\r\n\tend;\r\n```\r\nReplaces on delete cascade\r\n```sql\r\ncreate trigger t_delete_knd on knd\r\n\tafter delete\r\n\tas\r\n\tbegin\r\n\t\tdelete from bst where id_fi_k = (select id_kund from deleted)\r\n\tend;\r\n```",
  "author": "Debjit Purohit",
  "email": "debjit.shilpi@gmail.com",
  "date": "05/10/2022",
  "references": [
    "https://www.databasestar.com/sql-roadmap/",
    "https://roadmapit.com/database-management"
  ]
}
